<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beyblade Por Ruan Oliveira</title>
    <style>
        body {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            height: 100vh; margin: 0; background-color: #1f2a38;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white; text-align: center;
        }
        canvas {
            background-color: #34495e; border: 5px solid #ecf0f1;
            border-radius: 50%; cursor: pointer;
        }
        #game-info { display: flex; justify-content: space-around; width: 800px; margin-bottom: 15px; }
        h1, h2 { margin: 0; padding: 5px; }
        #restartButton {
            margin-top: 20px; padding: 10px 20px; font-size: 16px;
            cursor: pointer; background-color: #e74c3c; color: white;
            border: none; border-radius: 5px; display: none;
        }
    </style>
</head>
<body>

    <h1>Beyblade Por Ruan Oliveira</h1>
    <p id="instructions">
        Sobreviva até o Nível 10 para enfrentar o CHEFE FINAL!<br/>
        Ele é gigante, pesado e seu único objetivo é destruir você.
    </p>

    <div id="game-info"> <h2 id="levelInfo">Nível: 1</h2> <h2 id="status">Inimigos restantes: 1</h2> </div>
    <canvas id="gameCanvas" width="800" height="800"></canvas>
    <button id="restartButton">Jogar Novamente</button>

    <script>
        const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status'), levelInfoEl = document.getElementById('levelInfo'), restartButton = document.getElementById('restartButton');
        const ARENA_CENTER = { x: canvas.width / 2, y: canvas.height / 2 }, INITIAL_ARENA_RADIUS = canvas.width / 2 - 20, FRICTION = 0.985, PLAYER_ACCELERATION = 0.125, ENEMY_ACCELERATION = 0.125, RESTITUTION = 1.2, BOWL_EFFECT_GRAVITY = 0.00015, MAX_MOMENTUM_CHARGE = 120, MOMENTUM_SPEED_THRESHOLD = 0.5, ARENA_SHRINK_RATE = 0.015, POWERUP_SPAWN_INTERVAL = 300, ENEMY_POWERUP_GREED = 1.5, BOSS_LEVEL = 10;
        let player, enemies = [], powerUps = [], notifications = [], particles = [], keysPressed = {}, currentLevel = 1, isLevelTransitioning = false, isBossLevel = false, gameState = 'PRE_GAME', currentArenaRadius = INITIAL_ARENA_RADIUS, powerUpSpawnTimer = 0;

        class Particle { constructor(x, y, color) { this.x = x; this.y = y; this.color = color; this.radius = Math.random() * 2 + 1; this.vx = (Math.random() - 0.5) * (Math.random() * 6); this.vy = (Math.random() - 0.5) * (Math.random() * 6); this.ttl = 100; this.opacity = 1; } update() { this.x += this.vx; this.y += this.vy; this.ttl--; this.opacity = this.ttl / 100; } draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, 7); ctx.fillStyle = `rgba(${this.color}, ${this.opacity})`; ctx.fill(); } }
        class Beyblade { constructor(x,y,r,c,iP=false){this.x=x;this.y=y;this.radius=r;this.color=c;this.isPlayer=iP;this.vx=0;this.vy=0;this.isActive=true;this.baseMass=Math.PI*r*r;this.mass=this.baseMass;this.momentumCharge=0;this.speedBoost=1.0;this.spinAngle=Math.random()*7;this.trail=[];} drawTrail(){for(let i=0;i<this.trail.length;i++){const p=this.trail[i];const r=i/this.trail.length;ctx.beginPath();ctx.arc(p.x,p.y,this.radius*r,0,7);ctx.fillStyle=`rgba(255,255,255,${r*0.1})`;ctx.fill();}} draw(){if(!this.isActive)return;this.drawTrail();const cR=this.momentumCharge/MAX_MOMENTUM_CHARGE,cCB=Math.floor(255*(1-cR)),cCA=0.5+cR*0.5,cLW=3+cR*3;ctx.beginPath();ctx.arc(this.x,this.y,this.radius,0,7);ctx.fillStyle=this.color;ctx.fill();ctx.strokeStyle=`rgba(255,255,${cCB},${cCA})`;ctx.lineWidth=cLW;ctx.stroke();ctx.save();ctx.translate(this.x,this.y);ctx.rotate(this.spinAngle);const x_s=this.radius*0.5;ctx.beginPath();ctx.moveTo(-x_s,-x_s);ctx.lineTo(x_s,x_s);ctx.moveTo(x_s,-x_s);ctx.lineTo(-x_s,x_s);ctx.strokeStyle='rgba(0,0,0,0.4)';ctx.lineWidth=5;ctx.stroke();ctx.restore();} update(){if(!this.isActive)return;this.spinAngle+=0.2;this.trail.push({x:this.x,y:this.y});if(this.trail.length>15)this.trail.shift();const cS=Math.hypot(this.vx,this.vy);this.momentumCharge=cS>MOMENTUM_SPEED_THRESHOLD?Math.min(MAX_MOMENTUM_CHARGE,this.momentumCharge+1):Math.max(0,this.momentumCharge-2);const dX=ARENA_CENTER.x-this.x,dY=ARENA_CENTER.y-this.y;this.vx+=dX*BOWL_EFFECT_GRAVITY;this.vy+=dY*BOWL_EFFECT_GRAVITY;if(!this.isPlayer)this.updateAI();this.vx*=FRICTION;this.vy*=FRICTION;this.x+=this.vx;this.y+=this.vy;if(Math.hypot(this.x-ARENA_CENTER.x,this.y-ARENA_CENTER.y)+this.radius>currentArenaRadius){this.isActive=false;createExplosion(this.x,this.y,this.isPlayer?"52,152,219":"192,57,43");if(this.isPlayer&&!isBossLevel){endGame(`Você perdeu no Nível ${currentLevel}!`);}else if(this.isPlayer&&isBossLevel){endGame(`Você foi derrotado pelo Chefe!`);}}} updateAI(){} }
        class BossBeyblade extends Beyblade { constructor(x,y) { super(x,y,60,'#4b0082',false); this.mass = this.baseMass*5; this.speedBoost = 1.1; } draw() { if(!this.isActive) return; this.drawTrail(); const cR=this.momentumCharge/MAX_MOMENTUM_CHARGE,cCG=Math.floor(100*(1-cR)),cCB=Math.floor(100*(1-cR)),cCA=0.6+cR*0.4,cLW=5+cR*5; ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,7); ctx.fillStyle=this.color; ctx.fill(); ctx.strokeStyle=`rgba(255, ${cCG}, ${cCB}, ${cCA})`; ctx.lineWidth=cLW; ctx.stroke(); ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.spinAngle); const x_s=this.radius*0.6; ctx.beginPath(); ctx.moveTo(-x_s,-x_s); ctx.lineTo(x_s,x_s); ctx.moveTo(x_s,-x_s); ctx.lineTo(-x_s,x_s); ctx.strokeStyle='rgba(255,0,0,0.5)'; ctx.lineWidth=8; ctx.stroke(); ctx.restore(); } updateAI() { const b=(1+(this.momentumCharge/MAX_MOMENTUM_CHARGE))*this.speedBoost; if(player&&player.isActive) { const a=Math.atan2(player.y-this.y,player.x-this.x); this.vx+=Math.cos(a)*ENEMY_ACCELERATION*b; this.vy+=Math.sin(a)*ENEMY_ACCELERATION*b; } } }
        class PowerUp { constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.radius = 12; this.isActive = true; this.color = type === 'speed' ? 'rgba(52, 152, 219, 0.8)' : 'rgba(46, 204, 113, 0.8)'; this.symbol = type === 'speed' ? 'S' : 'M'; } draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, 7); ctx.fillStyle = this.color; ctx.fill(); ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = 'white'; ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.symbol, this.x, this.y); } }
        class Notification { constructor(text, x, y, color) { this.text = text; this.x = x; this.y = y; this.color = color; this.ttl = 60; } update() { this.y -= 0.5; this.ttl--; } draw() { ctx.save(); ctx.globalAlpha = Math.max(0, this.ttl / 60); ctx.fillStyle = this.color; ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center'; ctx.fillText(this.text, this.x, this.y); ctx.restore(); } }

        function drawArena() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath(); ctx.arc(ARENA_CENTER.x, ARENA_CENTER.y, currentArenaRadius, 0, 7);
            ctx.fillStyle = '#4a627a'; ctx.fill();
            const numRings = 10;
            for (let i = 1; i <= numRings; i++) { ctx.beginPath(); const ringRadius = (currentArenaRadius / numRings) * i; ctx.arc(ARENA_CENTER.x, ARENA_CENTER.y, ringRadius, 0, 7); ctx.strokeStyle = `rgba(255, 255, 255, ${0.02 + (i/numRings) * 0.08})`; ctx.lineWidth = 2; ctx.stroke(); }
            ctx.save(); ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 20;
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.7 + Math.random() * 0.3})`;
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.arc(ARENA_CENTER.x, ARENA_CENTER.y, currentArenaRadius - 2, 0, 7); ctx.stroke();
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(ARENA_CENTER.x, ARENA_CENTER.y, currentArenaRadius - 5, 0, 7); ctx.stroke();
            ctx.restore();
        }

        function createExplosion(x, y, color) { for (let i = 0; i < 30; i++) particles.push(new Particle(x, y, color)); }

        let gameLoopInstance;
        function gameLoop() {
            if (gameLoopInstance) return; gameLoopInstance = true;
            const loop = () => {
                if (gameState === 'GAME_OVER') { gameLoopInstance = false; return; }
                
                if (gameState === 'PLAYING') {
                    if (!isLevelTransitioning) {
                        currentArenaRadius = Math.max(player.radius * 2, currentArenaRadius - ARENA_SHRINK_RATE);
                        powerUpSpawnTimer++; if (powerUpSpawnTimer > POWERUP_SPAWN_INTERVAL) spawnPowerUp();
                    }
                    handlePlayerMovement();
                    particles.forEach(p => p.update());
                    [player, ...enemies].forEach(b => { if (b?.isActive) b.update(); });
                    notifications.forEach(n => n.update());
                    handlePowerUpCollection(); handleCollisions(); updateStatus();
                }
                
                drawArena();
                powerUps.forEach(p => p.draw());
                particles = particles.filter(p => p.ttl > 0);
                particles.forEach(p => p.draw());
                [player, ...enemies].forEach(b => { if (b?.isActive) b.draw(); });
                notifications = notifications.filter(n => n.ttl > 0);
                notifications.forEach(n => n.draw());
                
                if (gameState === 'PRE_GAME') {
                    // CORREÇÃO: Tutorial na tela inicial
                    ctx.textAlign = 'center';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.font = 'bold 40px Segoe UI';
                    ctx.fillText('Aperte qualquer tecla para começar', ARENA_CENTER.x, ARENA_CENTER.y - 40);
                    ctx.font = 'bold 20px Segoe UI';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fillText("Setas: Mover", ARENA_CENTER.x, ARENA_CENTER.y + 20);
                    ctx.fillText("ESC: Pausar", ARENA_CENTER.x, ARENA_CENTER.y + 50);
                } else if (gameState === 'PAUSED') {
                    ctx.save(); ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.textAlign = 'center'; ctx.font = 'bold 60px Segoe UI';
                    ctx.fillStyle = 'white';
                    ctx.fillText('PAUSADO', ARENA_CENTER.x, ARENA_CENTER.y);
                    ctx.restore();
                }
                
                requestAnimationFrame(loop);
            };
            requestAnimationFrame(loop);
        }
        
        window.addEventListener('keydown', (e) => {
            if (gameState === 'PRE_GAME') {
                startGame();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                if (gameState === 'PLAYING') gameState = 'PAUSED';
                else if (gameState === 'PAUSED') gameState = 'PLAYING';
            }
            keysPressed[e.key] = true;
        });

        // --- Funções Auxiliares (completas e corretas) ---
        init = function() { gameState = 'PRE_GAME'; isLevelTransitioning = false; isBossLevel = false; currentLevel = 1; currentArenaRadius = INITIAL_ARENA_RADIUS; powerUpSpawnTimer = 0; powerUps = []; notifications = []; particles = []; keysPressed = {}; restartButton.style.display = 'none'; player = new Beyblade(ARENA_CENTER.x, ARENA_CENTER.y + 250, 30, '#3498db', true); enemies = []; updateStatus(); if(!gameLoopInstance) gameLoop(); };
        Beyblade.prototype.updateAI = function() { const b=(1+(this.momentumCharge/MAX_MOMENTUM_CHARGE))*this.speedBoost;const dFC=Math.hypot(this.x-ARENA_CENTER.x,this.y-ARENA_CENTER.y);if(dFC>currentArenaRadius*0.85){const aTC=Math.atan2(ARENA_CENTER.y-this.y,ARENA_CENTER.x-this.x);this.vx+=Math.cos(aTC)*ENEMY_ACCELERATION*b*2;this.vy+=Math.sin(aTC)*ENEMY_ACCELERATION*b*2;return;}let cT=null,mTd=Infinity,cP=null,mPd=Infinity;[player,...enemies.filter(e=>e!==this)].forEach(t=>{if(t?.isActive){const d=Math.hypot(t.x-this.x,t.y-this.y);if(d<mTd){mTd=d;cT=t;}}});powerUps.forEach(p=>{if(p.isActive){const d=Math.hypot(p.x-this.x,p.y-this.y);if(d<mPd){mPd=d;cP=p;}}});let fT=null;if(cP&&(!cT||mPd<mTd*ENEMY_POWERUP_GREED)){fT=cP;}else if(cT){fT=cT;}if(fT){const aTT=Math.atan2(fT.y-this.y,fT.x-this.x);this.vx+=Math.cos(aTT)*ENEMY_ACCELERATION*b;this.vy+=Math.sin(aTT)*ENEMY_ACCELERATION*b;}};
        const setupLevel = function(level) { isLevelTransitioning = false; currentArenaRadius = INITIAL_ARENA_RADIUS; powerUps = []; enemies = []; currentLevel = level; levelInfoEl.textContent = `Nível: ${level}`; for (let i = 0; i < level; i++) { const a = (i/level)*7, d = 150+Math.random()*150; enemies.push(new Beyblade(ARENA_CENTER.x+Math.cos(a)*d, ARENA_CENTER.y+Math.sin(a)*d, 25, '#c0392b')); } updateStatus(); };
        const setupBossLevel = function() { isLevelTransitioning = false; isBossLevel = true; currentArenaRadius = INITIAL_ARENA_RADIUS; powerUps = []; enemies = []; levelInfoEl.textContent = `CHEFE FINAL`; enemies.push(new BossBeyblade(ARENA_CENTER.x, ARENA_CENTER.y - 150)); updateStatus(); };
        const updateStatus = function() { if (isBossLevel) { const b = enemies[0]; if (b && !b.isActive) { endGame("VOCÊ VENCEU! PARABÉNS!", true); } else { statusEl.textContent = "Derrote-o!"; } return; } const aE = enemies.filter(e => e.isActive).length; statusEl.textContent = `Inimigos restantes: ${aE}`; if (aE === 0 && player.isActive && gameState === 'PLAYING' && !isLevelTransitioning) { isLevelTransitioning = true; player.speedBoost = 1.0; player.mass = player.baseMass; player.vx = 0; player.vy = 0; player.momentumCharge = 0; player.x = ARENA_CENTER.x; player.y = ARENA_CENTER.y + 250; if (currentLevel === BOSS_LEVEL - 1) { setTimeout(setupBossLevel, 1500); } else { setTimeout(() => setupLevel(currentLevel + 1), 1500); } } };
        const endGame = function(message, isVictory = false) { gameState = 'GAME_OVER'; statusEl.textContent = message; statusEl.style.color = isVictory ? '#2ecc71' : '#e74c3c'; levelInfoEl.textContent = isVictory ? "FIM DE JOGO" : "TENTE NOVAMENTE"; restartButton.style.display = 'block'; };
        const startGame = function() { if (gameState === 'PRE_GAME') { gameState = 'PLAYING'; if (isBossLevel) { setupBossLevel() } else { setupLevel(currentLevel); } } }
        const handlePlayerMovement = function() { if (!player.isActive) return; const b = (1 + (player.momentumCharge / MAX_MOMENTUM_CHARGE)) * player.speedBoost; if (keysPressed['ArrowUp']) player.vy -= PLAYER_ACCELERATION * b; if (keysPressed['ArrowDown']) player.vy += PLAYER_ACCELERATION * b; if (keysPressed['ArrowLeft']) player.vx -= PLAYER_ACCELERATION * b; if (keysPressed['ArrowRight']) player.vx += PLAYER_ACCELERATION * b; };
        const handleCollisions = function() { const all = [player, ...enemies]; for (let i = 0; i < all.length; i++) { for (let j = i + 1; j < all.length; j++) { const b1 = all[i], b2 = all[j]; if (!b1?.isActive || !b2?.isActive) continue; const dX = b2.x - b1.x, dY = b2.y - b1.y, dist = Math.hypot(dX, dY), minD = b1.radius + b2.radius; if (dist < minD) { b1.momentumCharge = 0; b2.momentumCharge = 0; const a = Math.atan2(dY, dX), v1 = {x:b1.vx,y:b1.vy}, v2 = {x:b2.vx,y:b2.vy}, tM = b1.mass+b2.mass; b1.vx = (v1.x*(b1.mass-b2.mass)+2*b2.mass*v2.x)/tM*RESTITUTION; b1.vy = (v1.y*(b1.mass-b2.mass)+2*b2.mass*v2.y)/tM*RESTITUTION; b2.vx = (v2.x*(b2.mass-b1.mass)+2*b1.mass*v1.x)/tM*RESTITUTION; b2.vy = (v2.y*(b2.mass-b1.mass)+2*b1.mass*v1.y)/tM*RESTITUTION; const o = minD - dist, sX = (o*dX)/dist, sY = (o*dY)/dist; b1.x -= sX/2; b1.y -= sY/2; b2.x += sX/2; b2.y += sY/2; } } } };
        const spawnPowerUp = function() { powerUpSpawnTimer = 0; const t = Math.random() < 0.5 ? 'speed' : 'mass'; const a = Math.random() * 7; const d = Math.random() * (currentArenaRadius - 40); powerUps.push(new PowerUp(ARENA_CENTER.x + Math.cos(a) * d, ARENA_CENTER.y + Math.sin(a) * d, t)); };
        const handlePowerUpCollection = function() { [player, ...enemies].forEach(b => { if (!b.isActive) return; for (let i = powerUps.length - 1; i >= 0; i--) { const p = powerUps[i]; if (Math.hypot(b.x - p.x, b.y - p.y) < b.radius + p.radius) { if (p.type === 'speed') { b.speedBoost += 0.05; notifications.push(new Notification('+5% Vel.', b.x, b.y - b.radius, '#3498db')); } else { b.mass *= 1.08; notifications.push(new Notification('+8% Massa', b.x, b.y - b.radius, '#2ecc71')); } powerUps.splice(i, 1); } } }); };
        canvas.addEventListener('mousedown', () => { if (gameState === 'PRE_GAME') startGame(); });
        window.addEventListener('keyup', (e) => { keysPressed[e.key] = false; });
        restartButton.addEventListener('click', init);
        
        init();
    </script>
</body>
</html>
